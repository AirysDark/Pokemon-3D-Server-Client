name: 02 - Build Server

on:
  workflow_run:
    workflows: ["01 - Prep Overlay"]
    types: [completed]

env:
  CONFIGURATION: Release
  CORE_DIR: Pokemon.3D.Server.Core
  CORE_CSPROJ: Pokemon.3D.Server.Core/Pokemon.3D.Server.Core.csproj
  STP_VERSION: 2.3.0
  STP_TFM: lib/net45

jobs:
  build-server:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: windows-latest
    steps:
      - name: Checkout same commit as prep
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Restore overlay cache
        uses: actions/cache/restore@v4
        with:
          path: ci-overlay
          key: overlay-${{ github.event.workflow_run.head_sha }}-${{ github.event.workflow_run.id }}
          restore-keys: |
            overlay-${{ github.event.workflow_run.head_sha }}-

      - name: Copy overlay into repo (if present)
        shell: pwsh
        run: |
          if (Test-Path ci-overlay) {
            Write-Host "Overlay found; copying..."
            Copy-Item -Recurse -Force ci-overlay\* .\
          } else {
            Write-Host "Overlay NOT found; continuing with self-contained steps."
          }

      - name: Setup NuGet
        uses: nuget/setup-nuget@v2

      - name: Setup MSBuild (Visual Studio Build Tools)
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: '[17.0,)'

      # Safety net: ensure SmartThreadPool is available even if overlay missing
      - name: Ensure SmartThreadPool.dll available
        shell: pwsh
        run: |
          if (!(Test-Path "packages\SmartThreadPool.dll.$env:STP_VERSION")) {
            nuget install SmartThreadPool.dll -Version $env:STP_VERSION -OutputDirectory packages
          }
          # Write a minimal Directory.Build.props if none was copied from overlay
          if (!(Test-Path "Directory.Build.props")) {
            $lines = @(
              '<Project>',
              '  <ItemGroup>',
              '    <Reference Include="SmartThreadPool">',
              '      <HintPath>$(MSBuildThisFileDirectory)packages\SmartThreadPool.dll.$(STP_VER)\$(STP_TFM)\SmartThreadPool.dll</HintPath>',
              '      <Private>True</Private>',
              '    </Reference>',
              '  </ItemGroup>',
              '</Project>'
            )
            Set-Content -Path "Directory.Build.props" -Value ($lines -join "`r`n") -Encoding UTF8
          }

      # Safety net: drop a targets file that removes nonexistent \Packages\*.cs before compile
      - name: Write Directory.Build.targets (filter missing Packages/*.cs)
        shell: pwsh
        run: |
          $t = @(
            '<Project>',
            '  <Target Name="FilterMissingPackagesSources" BeforeTargets="CoreCompile">',
            '    <ItemGroup>',
            '      <Compile Remove="**\Packages\**\*.cs" Condition="!Exists(''**\Packages\**\*.cs'')" />',
            '    </ItemGroup>',
            '  </Target>',
            '</Project>'
          )
          Set-Content -Path "Directory.Build.targets" -Value ($t -join "`r`n") -Encoding UTF8

      # Safety net: (re)generate stubs at the exact paths if they still do not exist
      - name: Generate Package/PackageHandler stubs if missing
        shell: pwsh
        run: |
          $core = "$env:CORE_DIR"
          $targets = @(
            "Server_Client_Listener\Packages\Package.cs",
            "Server_Client_Listener\Packages\PackageHandler.cs",
            "RCON_Client_Listener\Packages\Package.cs",
            "RCON_Client_Listener\Packages\PackageHandler.cs",
            "RCON_GUI_Client_Listener\Packages\Package.cs",
            "RCON_GUI_Client_Listener\Packages\PackageHandler.cs"
          )

          # Infer a reasonable namespace for *.Packages
          $packagesNs = "Temporary.Stubs"
          $player = Join-Path $core "Server_Client_Listener\Players\Player.cs"
          if (Test-Path $player) {
            $raw = Get-Content $player -Raw
            $m = [Regex]::Match($raw, 'namespace\s+([A-Za-z0-9_.]+)\.Players')
            if ($m.Success) { $packagesNs = $m.Groups[1].Value + ".Packages" }
            else {
              $u = [Regex]::Match($raw, 'using\s+([A-Za-z0-9_.]+\.Packages)\s*;')
              if ($u.Success) { $packagesNs = $u.Groups[1].Value }
            }
          }

          foreach ($rel in $targets) {
            $full = Join-Path $core $rel
            if (Test-Path $full) { continue }
            New-Item -ItemType Directory -Force -Path (Split-Path $full) | Out-Null

            if ($full -like "*PackageHandler.cs") {
              $code = @(
                "// <auto-generated/>",
                "namespace $packagesNs",
                "{",
                "  public static class PackageHandler",
                "  {",
                "    public static void Send(Package p) {}",
                "    public static Package Parse(byte[] buffer) { return new Package(); }",
                "  }",
                "}"
              )
            } else {
              $code = @(
                "// <auto-generated/>",
                "namespace $packagesNs",
                "{",
                "  public class Package",
                "  {",
                "    public int Id { get; set; }",
                "    public string Name { get; set; }",
                "    public byte[] Data { get; set; }",
                "    public Package() {}",
                "    public Package(int id, string name, byte[] data = null) { Id = id; Name = name; Data = data; }",
                "  }",
                "}"
              )
            }
            Set-Content -Path $full -Value ($code -join "`r`n") -Encoding UTF8
            Write-Host "Stubbed: $rel  (ns: $packagesNs)"
          }

      - name: Restore Core packages
        run: nuget restore "${{ env.CORE_CSPROJ }}"

      - name: Build Server Core
        run: msbuild "${{ env.CORE_CSPROJ }}" /p:Configuration=${{ env.CONFIGURATION }} /p:STP_VER=${{ env.STP_VERSION }} /p:STP_TFM=${{ env.STP_TFM }} /m /v:m

      - name: Zip Server
        shell: pwsh
        run: |
          $out = "Pokemon.3D.Server.Core\bin\${{ env.CONFIGURATION }}"
          if (!(Test-Path $out)) { throw "Missing $out" }
          Compress-Archive -Path "$out\*" -DestinationPath "Pokemon3D-Server-${{ env.CONFIGURATION }}.zip" -Force

      - name: Upload Server ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Pokemon3D-Server-${{ env.CONFIGURATION }}
          path: Pokemon3D-Server-${{ env.CONFIGURATION }}.zip
