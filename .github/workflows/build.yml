name: Build Server & Client (auto-fix + stubs)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    env:
      CONFIGURATION: Release
      CORE_CSPROJ: Pokemon.3D.Server.Core/Pokemon.3D.Server.Core.csproj
      CLIENT_GUI_CSPROJ: Pokemon.3D.Server.Client.GUI/Pokemon.3D.Server.Client.GUI.csproj
      STP_VERSION: 2.3.0
      STP_LIB_TFM: lib/net45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup NuGet
        uses: nuget/setup-nuget@v2

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      # 1) Remove stale SmartThreadPool ProjectReference + guard any \Packages\*.cs includes
      - name: Patch csproj (strip bad ref + guard Packages)
        shell: pwsh
        run: |
          $core   = "${{ env.CORE_CSPROJ }}"
          $client = "${{ env.CLIENT_GUI_CSPROJ }}"

          $regexPR = '(?s)\s*<ProjectReference[^>]*SmartThreadPool\\SmartThreadPool\\SmartThreadPool\.csproj.*?</ProjectReference>'
          foreach ($f in @($core, $client)) {
            if (Test-Path $f) {
              $txt = Get-Content $f -Raw
              if ($txt -match $regexPR) {
                $txt = [Regex]::Replace($txt, $regexPR, '')
                Set-Content $f $txt
                Write-Host "Removed SmartThreadPool ProjectReference in $f"
              }
            }
          }

          function Guard-PackagesIncludes($projPath) {
            if (!(Test-Path $projPath)) { return }
            [xml]$xml = Get-Content $projPath -Raw
            $ns = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
            $ns.AddNamespace('msb', $xml.DocumentElement.NamespaceURI)
            $changed = $false
            foreach ($node in $xml.Project.SelectNodes("//msb:Compile[@Include]", $ns)) {
              $inc = $node.GetAttribute("Include")
              if ($inc -match "(?i)\\Packages\\.+\.cs$") {
                if (-not $node.HasAttribute("Condition")) {
                  $node.SetAttribute("Condition", "Exists('$inc')")
                  $changed = $true
                }
              }
            }
            if ($changed) {
              $xml.Save($projPath)
              Write-Host "Guarded \\Packages\\*.cs includes in $projPath"
            } else {
              Write-Host "No \\Packages\\*.cs includes to guard in $projPath"
            }
          }

          Guard-PackagesIncludes $core
          Guard-PackagesIncludes $client

      # 2) Vendor SmartThreadPool via NuGet (correct package id: SmartThreadPool.dll)
      - name: Fetch SmartThreadPool.dll package
        shell: pwsh
        run: |
          nuget install SmartThreadPool.dll -Version "${{ env.STP_VERSION }}" -OutputDirectory packages
          $pkg = Join-Path "packages" ("SmartThreadPool.dll." + "${{ env.STP_VERSION }}")
          if (!(Test-Path $pkg)) { throw "SmartThreadPool.dll package not found: $pkg" }
          $dll = Join-Path $pkg (Join-Path "${{ env.STP_LIB_TFM }}" "SmartThreadPool.dll")
          if (!(Test-Path $dll)) { throw "SmartThreadPool.dll not found: $dll" }
          Write-Host "Using SmartThreadPool: $dll"

      - name: Inject SmartThreadPool Reference (Core)
        shell: pwsh
        run: |
          $core = "${{ env.CORE_CSPROJ }}"
          if (!(Test-Path $core)) { throw "Missing $core" }
          $hint = "..\packages\SmartThreadPool.dll.${{ env.STP_VERSION }}\${{ env.STP_LIB_TFM }}\SmartThreadPool.dll"
          $xml  = Get-Content $core -Raw
          if ($xml -notmatch 'Reference Include="SmartThreadPool"') {
            $ref = "  <ItemGroup>`n    <Reference Include=""SmartThreadPool"">`n      <HintPath>$hint</HintPath>`n      <Private>True</Private>`n    </Reference>`n  </ItemGroup>`n"
            $xml = [Regex]::Replace($xml, '(?s)</Project>\s*$', ($ref + '</Project>'))
            Set-Content $core $xml
            Write-Host "Added SmartThreadPool reference to Core"
          } else {
            Write-Host "Core already has SmartThreadPool reference"
          }

      - name: Inject SmartThreadPool Reference (Client if needed)
        shell: pwsh
        run: |
          $client = "${{ env.CLIENT_GUI_CSPROJ }}"
          if (!(Test-Path $client)) { exit 0 }
          $raw = Get-Content $client -Raw
          if ($raw -match 'Amib\.Threading' -and $raw -notmatch 'Reference Include="SmartThreadPool"') {
            $hint = "..\packages\SmartThreadPool.dll.${{ env.STP_VERSION }}\${{ env.STP_LIB_TFM }}\SmartThreadPool.dll"
            $ref  = "  <ItemGroup>`n    <Reference Include=""SmartThreadPool"">`n      <HintPath>$hint</HintPath>`n      <Private>True</Private>`n    </Reference>`n  </ItemGroup>`n"
            $raw  = [Regex]::Replace($raw, '(?s)</Project>\s*$', ($ref + '</Project>'))
            Set-Content $client $raw
            Write-Host "Added SmartThreadPool reference to Client"
          } else {
            Write-Host "Client STP reference not needed or already present"
          }

      # 3) If Packages/*.cs are missing, generate minimal stubs so types exist
      - name: Generate stubs for missing Package/PackageHandler
        shell: pwsh
        run: |
          $coreDir = Split-Path "${{ env.CORE_CSPROJ }}"
          $player  = Join-Path $coreDir "Server_Client_Listener\Players\Player.cs"
          $ns = $null

          # Try to infer namespace from Player.cs
          if (Test-Path $player) {
            $text = Get-Content $player -Raw
            $m = [Regex]::Match($text, 'namespace\s+([A-Za-z0-9_.]+)')
            if ($m.Success) { $ns = $m.Groups[1].Value }
            # Prefer a using ...Packages; if present
            $u = [Regex]::Match($text, 'using\s+([A-Za-z0-9_.]+\.Packages)\s*;')
            if ($u.Success) { $ns = $u.Groups[1].Value }
          }
          if (-not $ns) { $ns = "Temporary.Stubs" }  # fallback

          $stubDir = Join-Path $coreDir "_GeneratedStubs"
          New-Item -ItemType Directory -Force -Path $stubDir | Out-Null
          $pkgFile = Join-Path $stubDir "Package.cs"
          $hdlFile = Join-Path $stubDir "PackageHandler.cs"

          $pkgSrc = @"
// <auto-generated/>
namespace $ns
{
    public class Package
    {
        // Minimal surface so code compiles; extend if the build later requests members
        public int Id { get; set; }
        public string Name { get; set; }
        public byte[] Data { get; set; }
        public Package() {}
        public Package(int id, string name, byte[] data = null) { Id = id; Name = name; Data = data; }
    }
}
"
          $hdlSrc = @"
// <auto-generated/>
namespace $ns
{
    public static class PackageHandler
    {
        // Provide no-op handlers; extend if compile asks for specific APIs
        public static void Send(Package p) { }
        public static Package Parse(byte[] buffer) { return new Package(); }
    }
}
"
          Set-Content -Path $pkgFile -Value $pkgSrc -Encoding UTF8
          Set-Content -Path $hdlFile -Value $hdlSrc -Encoding UTF8

          # Ensure Core csproj includes the generated stubs
          $csproj = "${{ env.CORE_CSPROJ }}"
          $xml = Get-Content $csproj -Raw
          if ($xml -notmatch "_GeneratedStubs") {
            $add = "  <ItemGroup>`n    <Compile Include=""_GeneratedStubs\Package.cs"" />`n    <Compile Include=""_GeneratedStubs\PackageHandler.cs"" />`n  </ItemGroup>`n"
            $xml = [Regex]::Replace($xml, '(?s)</Project>\s*$', ($add + '</Project>'))
            Set-Content $csproj $xml
            Write-Host "Injected generated stubs into Core csproj under namespace: $ns"
          } else {
            Write-Host "Stub entries already present in csproj."
          }

      # 4) Restore remaining NuGet packages (Newtonsoft.Json, SharpCompress, etc.)
      - name: Restore Core packages
        run: nuget restore "${{ env.CORE_CSPROJ }}"
      - name: Restore Client packages
        run: nuget restore "${{ env.CLIENT_GUI_CSPROJ }}"

      # 5) Build both projects
      - name: Build Server Core
        run: msbuild "${{ env.CORE_CSPROJ }}" /p:Configuration=${{ env.CONFIGURATION }} /m /v:m
      - name: Build Client GUI
        run: msbuild "${{ env.CLIENT_GUI_CSPROJ }}" /p:Configuration=${{ env.CONFIGURATION }} /m /v:m

      # 6) Package artifacts
      - name: Zip Server
        shell: pwsh
        run: |
          $out = "Pokemon.3D.Server.Core\bin\${{ env.CONFIGURATION }}"
          if (!(Test-Path $out)) { throw "Missing $out" }
          Compress-Archive -Path "$out\*" -DestinationPath "Pokemon3D-Server-${{ env.CONFIGURATION }}.zip" -Force

      - name: Zip Client
        shell: pwsh
        run: |
          $out = "Pokemon.3D.Server.Client.GUI\bin\${{ env.CONFIGURATION }}"
          if (!(Test-Path $out)) { throw "Missing $out" }
          Compress-Archive -Path "$out\*" -DestinationPath "Pokemon3D-Client-${{ env.CONFIGURATION }}.zip" -Force

      - name: Upload Server ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Pokemon3D-Server-${{ env.CONFIGURATION }}
          path: Pokemon3D-Server-${{ env.CONFIGURATION }}.zip

      - name: Upload Client ZIP
        uses: actions/upload-artifact@v4
        with:
          name: Pokemon3D-Client-${{ env.CONFIGURATION }}
          path: Pokemon3D-Client-${{ env.CONFIGURATION }}.zip
